/**
 * @file   <sps/win32/memory>
 * @author Jens Munk Hansen <jens.munk.hansen@gmail.com>
 * @date   Sun Apr 23 13:17:10 2017
 *
 * @brief  Memory related functions
 *
 *
 */
#pragma once

#include <sps/cenv.h>

#include <memory>
#include <type_traits>

/*
  TODO: Consider using sps::align<32> and/or renaming base_align16 to
  sps_base_align16 and move it to a C header
*/
namespace sps {
namespace win32 {

#ifdef _MSC_VER
# pragma warning(push)
# pragma warning(disable : 4324)
#endif
ALIGN16_BEGIN struct ALIGN16_END base_align16 {
  /*
    Empty classes are "special" because the standard requires that no complete object have size 0,
    so a class with no data members or bases always requires some padding if it doesn't have a vtable.

    Apparently, MSVC creates a struct of size 16, if a struct of size 16 is derived from a struct of
    size 0, so we have removed this and ignored warning 4324

  */
  //      char dummy[16];
};
ALIGN32_BEGIN struct ALIGN32_END base_align32 {
};
#ifdef _MSC_VER
# pragma warning(pop)
#endif

/*
  Using Microsoft Visual Studio 2013, the following construct
  works.

  auto del = [](T* p) {
  _mm_free(p);
  };
  std::unique_ptr<T[], decltype(del)> bla((T*)_mm_malloc(sizeof(T)*nDivW,16), del);

  A bug in Visual Studio 2013 causes the below expression to fail with a message about a
  deleted function is referenced

  typedef std::unique_ptr<T[], std::function<void(T*)> > deleted_unique_array;

  http://stackoverflow.com/questions/30578497/unique-ptr-constructor-with-custom-deleter-is-deleted

*/

template<typename T>
class deleted_aligned_array {
 public:
  /*
     A much simpler approach works using GCC

     typedef std::unique_ptr<T[], std::function<void(T*)> > deleted_unique_array;

     deleted_aligned_array(size_t n) : m_data((T*)_mm_malloc(n*sizeof(T),16), [](T* p) {_mm_free(p);}) {};

     or

     static void deleter(T* p)
     {
       _mm_free(p);
     }

     deleted_aligned_array(size_t n) : m_data((T*)_mm_malloc(n*sizeof(T),16),
                                              std::bind(&deleted_aligned_array::deleter,
                                                        this, std::placeholders::_1)) {}
   */
  typedef T* pointer;

  deleted_aligned_array() : m_data() {}

  // 32-byte aligned to allow 4-vectors of doubles
  deleted_aligned_array(size_t n) : m_data((T*)_mm_malloc(n*sizeof(T),32), [](T* p) {_mm_free(p);}) {}

  deleted_aligned_array(deleted_aligned_array&& other) : m_data(std::move(other.m_data)) {}

  deleted_aligned_array& operator=( deleted_aligned_array&& other ) {
    m_data = std::move( other.m_data );
    return *this;
  }

  T& operator[](const size_t i) {
    return m_data.get()[i];
  }

  const T& operator[](const size_t i) const {
    return m_data.get()[i];
  }

  T* get() noexcept {
    return m_data.get();
  }

  const T* get() const noexcept {
    return m_data.get();
  }

  void reset(pointer p = pointer()) noexcept {
    m_data.reset(p);
  }

  typename std::unique_ptr<T, std::function<void(T*)> >::deleter_type& get_deleter() noexcept {
    return m_data.get_deleter();
  }

  const typename std::unique_ptr<T, std::function<void(T*)> >::deleter_type& get_deleter() const noexcept {
    return m_data.get_deleter();
  }

 private:
  typedef std::unique_ptr<T, std::function<void(T*)> > deleted_unique_array;
  deleted_aligned_array(const deleted_aligned_array& other) = delete;
  deleted_aligned_array& operator=( const deleted_aligned_array& a ) = delete;
  deleted_unique_array m_data;
};

template <class T>
deleted_aligned_array<T> deleted_aligned_array_create(size_t n) {
  return deleted_aligned_array<T>(n);
}

template <class T, size_t D>
class deleted_aligned_multi_array {
};

template <class T>
class deleted_aligned_multi_array<T, 2> {
 public:
  typedef T** pointer;
  typedef const T** const_pointer;

  deleted_aligned_multi_array() : m_data(), m_m(0), m_n(0) {}

  deleted_aligned_multi_array(size_t m, size_t n) :
    m_data(new T*[m](),
           [](T** x) {
# ifndef _DEBUG
              if (msize(x) > sizeof(intptr_t)) {
                _mm_free(&(x[0][0]));
              }
# else
             if (msize(x) > 0) {
               _mm_free(&(x[0][0]));
             }
# endif
             delete[] x;}), m_m(m), m_n(n) {
    // Allocate
    if (m_m*m_n > 0) {
      // 32-byte aligned to allow 4-vectors of doubles
      m_data.get()[0] = (T*) _mm_malloc(m_m*m_n*sizeof(T),32);

      // Row pointers. First pointer may screw up de-allocation.
      for (size_t iRow = 1; iRow < m_m; iRow++) {
        (m_data.get())[iRow] = &(m_data.get()[0][iRow*m_n]);
      }
    }
  }
  deleted_aligned_multi_array(deleted_aligned_multi_array&& other) :
    m_data(std::move(other.m_data)), m_m(other.m_m), m_n(other.m_n) {}

  // Dangerous
  deleted_aligned_multi_array& operator=( deleted_aligned_multi_array&& other) {
    if (this != &other) {
      m_data = std::move( other.m_data );
      m_m    = other.m_m;
      m_n    = other.m_n;
    }
    return *this;
  }

  T& operator()(size_t i, size_t j) {
    return this->m_data.get()[0][i*m_n + j];
  }

  T* operator[](size_t m) {
    return &(m_data.get()[m][0]);
  }

  const T* operator[](size_t m) const {
    return m_data.get()[m];
  }

  pointer get() {
    return m_data.get();
  }

  const_pointer get() const {
    return const_cast<const_pointer>(m_data.get());
  }

  void reset(pointer __p = pointer()) {
    m_data.reset(__p);
  }

 template<typename _Up>
 void reset(_Up) = delete;

 private:
  typedef std::unique_ptr<T*, std::function<void(T**)>> deleted_unique_array;
  deleted_aligned_multi_array(const deleted_aligned_multi_array& other) = delete;
  deleted_aligned_multi_array& operator=( const deleted_aligned_multi_array& a ) = delete;

  deleted_unique_array m_data;  ///<Data
 public:
  size_t m_m; ///<Number of rows
  size_t m_n; ///<Number of columns
};

// Temporarily disable this
#if 1

// Work-around to partially specialize a function (multiple dimensions)
template <class T, size_t I>
inline typename std::enable_if<I == 2, deleted_aligned_multi_array<T, 2> >::type
deleted_aligned_multi_array_create(size_t m, size_t n) {
  return deleted_aligned_multi_array<T,2>(m,n);
}
#endif
}  // namespace win32
}  // namespace sps

/* Local variables: */
/* mode: c++ */
/* indent-tabs-mode: nil */
/* tab-width: 2 */
/* c-basic-offset: 2 */
/* End: */
