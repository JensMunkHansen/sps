/**
 * @file   <sps/unix/memory>
 * @author Jens Munk Hansen <jens.munk.hansen@gmail.com>
 * @date   Thu Mar 23 22:48:58 2017
 *
 * @brief  Memory related functions
 *
 *
 */
#pragma once

#include <sps/mm_malloc.h>

#ifndef __cplusplus
# error This is a C++ header
#endif

#include <algorithm>
#include <cassert>

#include <cstdarg>

#include <type_traits>

namespace sps {
namespace nix {
template<typename T>
using deleted_aligned_array = std::unique_ptr<T[], std::function<void(T*)> >;

/**
 * Create unique aligned array with custom deleter
 *
 * @tparam T type
 * @param n  length
 *
 * @return
 */
template<typename T>
deleted_aligned_array<T> deleted_aligned_array_create(size_t n) {
  return deleted_aligned_array<T>( static_cast<T*>(SPS_MM_MALLOC(n*sizeof(T), 32)),
                                  [](T* f)->void { _mm_free(f);});
}

//! Aligned multi-dimensional array
/*! Aligned multi-dimensional array, which is automatically deleted like a unique ptr */
template <class T, size_t D>
class deleted_aligned_multi_array {
};

template <class T>
class deleted_aligned_multi_array<T, 1> : public std::unique_ptr<T[], std::function<void(T*)> >{
  deleted_aligned_multi_array(size_t n) :
      // 32-byte aligned to allow 4-vectors of doubles
      std::unique_ptr<T[], std::function<void(T*)> >(static_cast<T*>(SPS_MM_MALLOC(n*sizeof(T), 32)), // Used for other objects
                                                   [](T* f)->void { _mm_free(f);}) {}
};

template <class T>
class deleted_aligned_multi_array<T, 2> {
public:
  typedef T** pointer;
  typedef const T** const_pointer;
  typedef std::unique_ptr<T*, std::function<void(T**)>> deleted_unique_array;

  /**
   * Default constructor
   *
   */
  deleted_aligned_multi_array() : m_m(0), m_n(0), data() {}

  /**
   *
   *
   * @param m
   * @param n
   */
  deleted_aligned_multi_array(size_t m, size_t n) : m_m(m), m_n(n) {
    if (m*n > 0) {
      data = deleted_unique_array(new T*[m](),
                                    [&](T** x) {
                                      // Not required, but would be cool to use initializer
                                      if (msize(x) > 0) {
                                        _mm_free(&(x[0][0]));
                                      }
                                      delete[] x;});
    }
    else {
      data.reset();
    }

    // Allocate
    if (m*n > 0) {
      // 32-byte aligned to allow 4-vectors of doubles - gives error if 4*sizeof(T)
      data.get()[0] = static_cast<T*>(SPS_MM_MALLOC(m*n*sizeof(T), 32));

      // Row pointers. First pointer may screw up de-allocation.
      for (size_t iRow = 1; iRow < m; iRow++) {
        (data.get())[iRow] = &(data.get()[0][iRow*n]);
      }
    }
  }

  /**
   * Move constructor
   *
   * @param other
   */
  deleted_aligned_multi_array(deleted_aligned_multi_array&& other) : m_m(std::move(other.m_m)), m_n(std::move(other.m_n)), data(std::move(other.data)) { }

  /**
   * Move assignment
   *
   * @param other
   *
   * @return
   */
  deleted_aligned_multi_array& operator=( deleted_aligned_multi_array&& other ) {
    if (this != &other) {
      this->data = std::move( other.data );
      this->m_m  = std::move( other.m_m );
      this->m_n  = std::move( other.m_n );
    }
    return *this;
  }

  /**
   * Get reference to element
   *
   * @param i
   * @param j
   *
   * @return reference to element
   */
  T& operator()(size_t i, size_t j) {
    return this->data.get()[0][i*m_n + j];
  }

  /**
   * Get row pointer
   *
   * @param row
   *
   * @return
   */
  T* operator[](size_t row) {
    return &(data.get()[row][0]);
  }

  /**
   * Get const row pointer
   *
   * @param row
   *
   * @return
   */
  const T* operator[](size_t row) const {
    return data.get()[row];
  }

  /**
   * Get pointer to data
   *
   *
   * @return
   */
  pointer get() {
    return data.get();
  }

  /**
   * Get const pointer to data
   *
   *
   * @return
   */
  const_pointer get() const {
    return const_cast<const T**>(data.get());
  }

  /**
   *
   *
   * @param __p
   */
  void reset(pointer __p = pointer()) {
    data.reset(__p);
  }

  /**
   *
   *
   * @tparam _Up
   */
  template<typename _Up>
  void reset(_Up) = delete;

 private:
  deleted_aligned_multi_array(const deleted_aligned_multi_array& other) = delete;
  deleted_aligned_multi_array& operator=( const deleted_aligned_multi_array& a ) = delete;

 public:
  size_t m_m;                   ///<Number of rows
  size_t m_n;                   ///<Number of columns
  deleted_unique_array data;  ///<Data
};

#if 1
// Work-around to partially specialize a function (multiple dimensions)
template <class T, size_t I>
inline typename std::enable_if<I==2, deleted_aligned_multi_array<T,2> >::type
deleted_aligned_multi_array_create(size_t m, size_t n) {
  return deleted_aligned_multi_array<T,2>(m,n);
}
#endif

// If we don't care about contiguous-ness, we can do the following (fix recursive type)
template <class T, size_t d>
class multi_array {
 public:
  typedef std::unique_ptr<T[]> ManagedC;
  // Very bad, may cause infinite memory usage
  multi_array(...) {
    va_list ap;             /* varargs list traverser */
    size_t *d1;             /* dimension list */
    va_start(ap,d);
    d1 = (size_t *) SPS_MALLOC(d*sizeof(size_t));
    size_t i;               /* loop counters */
    for(i=0; i<d; i++)
      d1[i] = va_arg(ap,size_t);

    // TODO: Figure out how to declara member variable
    auto managed_array = std::unique_ptr<ManagedC[]>(new ManagedC[d1[0]]);
    for (size_t i = 0; i < d1[0]; ++i)
      managed_array[i] = ManagedC(new T[d1[1]]);
    free(d1);
  }
};
}
}

/* Local variables: */
/* mode: c++ */
/* indent-tabs-mode: nil */
/* tab-width: 2 */
/* c-basic-offset: 2 */
/* End: */
