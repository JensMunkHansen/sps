/**
 * @file   "sps/memory"
 * @author Jens Munk Hansen <jens.munk.hansen@gmail.com>
 * @date   Sun May  7 10:34:25 2017
 *
 * @brief
 *
 *
 */
#pragma once

#include <sps/cenv.h>
#include <sps/mm_malloc.h>
#include <sps/malloc.h>

#ifndef __cplusplus
# error This is a C++ header
#endif

#include <memory>
#include <functional>
#include <type_traits>

#include <sps/align.hpp>
#include <sps/win32/memory>
#include <sps/unix/memory>

#ifndef CXX11
// Backport std::make_unique from C++14
namespace std {
  template<typename T, typename ...Args>
  std::unique_ptr<T> make_unique(Args&& ...args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
  }
} // namespace std
#endif // CX11

// TODO(JMH): Consider requiring descendant to be non-copyconstructible
template<bool B, typename T = void> using disable_if = std::enable_if<!B, T>;

namespace sps {
#if (defined(__GNUG__) && __cplusplus >= 201103L)
  using sps::nix::unique_aligned_array;
  using sps::nix::unique_aligned_array_create;

  using sps::nix::unique_aligned_multi_array;
  using sps::nix::unique_aligned_multi_array_create;

  // Alias type to unique_multi_array
  template <class T, size_t I, class H = typename std::enable_if<std::is_pod<T>::value>::type>
  using unique_multi_array = sps::nix::unique_aligned_multi_array<T, I, H>;

  // Alias function to unique_multi_array_create (TODO: Do this correctly)
#if 0
  template <class T, size_t I>
  inline typename std::enable_if<I==2, unique_aligned_multi_array<T,2> >::type
  unique_multi_array_create(size_t m, size_t n) {
    return sps::nix::unique_aligned_multi_array_create<T,I>(m,n);
  }
#elif 1
  // Works
  template <class T, size_t I, typename... Args>
  auto unique_multi_array_create(Args&&... args) -> decltype(sps::nix::unique_aligned_multi_array_create<T,I>(std::forward<Args>(args)...)) {
    return sps::nix::unique_aligned_multi_array_create<T,I>(args...);
  }
#else
  // How
  template <typename ...ExplicitArgs, typename... Args>
  auto unique_multi_array_create(Args&&... args) -> decltype(sps::nix::unique_aligned_multi_array_create<ExplicitArgs...>(std::forward<Args>(args)...)) {
    return sps::nix::unique_aligned_multi_array_create<ExplicitArgs...>(args...);
  }
#endif


  // Leveled pointers and pointer levels
  template <typename T>
  struct ptr_depth_impl
  {
    enum { level = 0 };
  };

  template <typename T>
  struct ptr_depth_impl<T* const volatile>
  {
    enum { level = ptr_depth_impl<T const volatile>::level + 1 };
  };

  template <typename T>
  struct ptr_depth
  {
    enum { level = ptr_depth_impl<T const volatile>::level };
  };

  template <typename T, size_t lvl>
  struct depth_ptr
  {
    using value_type = typename depth_ptr<T*,lvl-1>::value_type;
  };

#ifndef __clang__
  // Can we do this in general
  template <>
#endif
  template <typename T>
  struct depth_ptr<T,0> {
    using value_type = T;
  };
#elif defined(_MSC_VER)

  // TODO: Figure out how Microsoft reveals true C++11
  using sps::win32::base_align16;
  using sps::win32::base_align32;

  using sps::win32::unique_aligned_array;
  using sps::win32::unique_aligned_array_create;

  using sps::win32::unique_aligned_multi_array;
  using sps::win32::unique_aligned_multi_array_create;
#else
  #error This library needs at least a C++11 compliant compiler
#endif
}  // namespace std

/* Local variables: */
/* mode: c++ */
/* indent-tabs-mode: nil */
/* tab-width: 2 */
/* c-basic-offset: 2 */
/* End: */
